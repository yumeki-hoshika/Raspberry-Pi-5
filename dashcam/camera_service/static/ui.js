// Sensor service port (sensor_serviceを81で起動する想定)const SENSOR_PORT = 81;const SENSOR_BASE = `${location.protocol}//${location.hostname}:${SENSOR_PORT}`;function attachImgOverlay(img, overlay){  let okOnce = false;  img.addEventListener("load", ()=>{ okOnce = true; overlay.style.display = "none"; });  img.addEventListener("error", ()=>{ overlay.style.display = "grid"; });  setTimeout(()=>{ if(!okOnce) overlay.style.display="grid"; }, 1200);}const img0 = document.getElementById("img0");const img1 = document.getElementById("img1");attachImgOverlay(img0, document.getElementById("ov0"));attachImgOverlay(img1, document.getElementById("ov1"));function debounce(fn, ms){  let t=null;  return (...args)=>{    if(t) clearTimeout(t);    t=setTimeout(()=>fn(...args), ms);  };}async function postJSON(url, obj){  const r = await fetch(url, {method:"POST", headers:{'Content-Type':'application/json'}, body: JSON.stringify(obj)});  if(!r.ok){    const t = await r.text();    throw new Error(`${r.status} ${t}`);  }  return r.json().catch(()=> ({}));}// EV slidersconst ev0 = document.getElementById("ev0");const ev1 = document.getElementById("ev1");const ev0v = document.getElementById("ev0v");const ev1v = document.getElementById("ev1v");const sendEv0 = debounce((v)=> postJSON("/api/cam/0/ev", {ev: Number(v)}), 200);const sendEv1 = debounce((v)=> postJSON("/api/cam/1/ev", {ev: Number(v)}), 200);ev0.addEventListener("input", ()=>{ ev0v.textContent = ev0.value; sendEv0(ev0.value); });ev1.addEventListener("input", ()=>{ ev1v.textContent = ev1.value; sendEv1(ev1.value); });// Fullscreen modalconst modal = document.getElementById("modal");const full = document.getElementById("full");const closeBtn = document.getElementById("close");const ovFull = document.getElementById("ovFull");function openFull(cam){  full.src = cam === 0 ? "/stream/0" : "/stream/1";  ovFull.style.display = "grid";  modal.classList.remove("hidden");  setTimeout(()=>{ ovFull.style.display="none"; }, 1200);}function closeFull(){  modal.classList.add("hidden");  full.src = "";}closeBtn.onclick = closeFull;modal.addEventListener("click", (e)=>{ if(e.target === modal) closeFull(); });document.querySelectorAll(".cam-tile").forEach(tile=>{  tile.addEventListener("click", ()=>{    const cam = Number(tile.dataset.cam);    openFull(cam);  });});// Last Shotconst last0 = document.getElementById("last0");const last1 = document.getElementById("last1");const last0link = document.getElementById("last0link");const last1link = document.getElementById("last1link");const lastMeta = document.getElementById("lastMeta");const EMPTY_IMG = "data:image/gif;base64,R0lGODlhAQABAAAAACw=";last0.src = EMPTY_IMG;last1.src = EMPTY_IMG;last0link.href = "#";last1link.href = "#";lastMeta.textContent = "---";// Captureconst capShot = document.getElementById("capShot");const capState = document.getElementById("capState");capShot.onclick = async ()=>{  try{    capShot.disabled = true;    capState.textContent = "capturing...";    const r = await fetch("/api/capture/shot", {method:"POST"});    const j = await r.json();    capState.textContent = `saved: ${j.session_id} #${j.index}`;    const filename = String(j.index).padStart(6, "0") + ".jpg";    const sid = j.session_id;    const url0 = `/download/cam0/${sid}/${filename}?t=${Date.now()}`;    const url1 = `/download/cam1/${sid}/${filename}?t=${Date.now()}`;    last0.src = url0;    last1.src = url1;    last0link.href = url0;    last1link.href = url1;    lastMeta.textContent = `${sid}  ${filename}`;  } finally {    capShot.disabled = false;  }};// ===== LED toggle =====const ledToggle = document.getElementById("ledToggle");const ledState = document.getElementById("ledState");async function refreshLed(){  try{    const r = await fetch("/api/led");    const j = await r.json();    ledToggle.checked = !!j.on;    ledState.textContent = j.on ? "ON" : "OFF";  }catch(e){    ledState.textContent = "LED API error";  }}ledToggle.addEventListener("change", async ()=>{  try{    ledState.textContent = "setting...";    await postJSON("/api/led", {on: ledToggle.checked});    await refreshLed();  }catch(e){    ledState.textContent = `ERROR: ${e.message}`;    // 失敗時は状態を戻す    await refreshLed();  }});refreshLed();// ===== HUD + graph via SSE =====const headingEl = document.getElementById("heading");const distEl = document.getElementById("distance");const distqEl = document.getElementById("distq");const distStatus = document.getElementById("distStatus");const canvas = document.getElementById("distChart");const ctx = canvas.getContext("2d");let windowMin = 5;let windowMs = windowMin * 60 * 1000;const buf = []; // {t, d|null, st}function setWindowMinutes(min){  windowMin = min;  windowMs = min * 60 * 1000;  document.querySelectorAll(".range-btn").forEach(b=>{    b.classList.toggle("active", Number(b.dataset.min) === min);  });  draw();}document.querySelectorAll(".range-btn").forEach(btn=>{  btn.addEventListener("click", ()=> setWindowMinutes(Number(btn.dataset.min)));});function drawAxes(w,h, lo, hi){  ctx.beginPath();  ctx.moveTo(30, 10); ctx.lineTo(30, h-15); ctx.lineTo(w-10, h-15);  ctx.strokeStyle = "#444";  ctx.stroke();  ctx.fillStyle = "#aaa";  ctx.font = "12px system-ui";  ctx.fillText(`${hi.toFixed(2)} m`, 35, 20);  ctx.fillText(`${lo.toFixed(2)} m`, 35, h-20);  ctx.fillText(`${windowMin} min ago`, 35, h-2);  ctx.fillText(`now`, w-40, h-2);}function draw(){  const w = canvas.width, h = canvas.height;  ctx.clearRect(0,0,w,h);  const now = Date.now();  const tStart = now - windowMs;  const view = buf.filter(p=>p.t >= tStart);  const ds = view.map(p=>p.d).filter(d=>Number.isFinite(d));  if(ds.length < 2){    drawAxes(w,h, 0, 1);    return;  }  const minD = Math.min(...ds), maxD = Math.max(...ds);  const pad = (maxD-minD)*0.1 || 0.1;  const lo = minD - pad, hi = maxD + pad;  drawAxes(w,h, lo, hi);  const x = (t)=> ((t - tStart)/(windowMs||1))*(w-40)+30;  const y = (d)=> h - ((d - lo)/(hi - lo || 1))*(h-30) - 15;  ctx.beginPath();  ctx.strokeStyle = "#ddd";  let pen = false;  for(const p of view){    if(!Number.isFinite(p.d)){      pen = false;      continue;    }    const xx = x(p.t), yy = y(p.d);    if(!pen){ ctx.moveTo(xx,yy); pen=true; }    else ctx.lineTo(xx,yy);  }  ctx.stroke();}function startSSE(){  const es = new EventSource(`${SENSOR_BASE}/api/sensors/stream`);  es.addEventListener("sensors", (e)=>{    const msg = JSON.parse(e.data);    if(msg.heading_deg_avg == null) headingEl.textContent = "---";    else headingEl.textContent = msg.heading_deg_avg.toFixed(1);    const st = msg.distance_status || "NO_DATA";    const vr = (typeof msg.distance_valid_ratio === "number") ? Math.round(msg.distance_valid_ratio*100) : null;    if(st === "OK" && msg.distance_mm_avg != null){      distEl.textContent = (msg.distance_mm_avg/1000.0).toFixed(3);    }else{      distEl.textContent = "---";    }    distqEl.textContent = (vr == null) ? st : `${st}  valid=${vr}%`;    distStatus.textContent = distqEl.textContent;    const now = Date.now();    const d = (st === "OK" && msg.distance_mm_avg != null) ? (msg.distance_mm_avg/1000.0) : null;    buf.push({t: now, d, st});    const cutoff = now - 16*60*1000;    while(buf.length && buf[0].t < cutoff) buf.shift();    draw();  });  es.onerror = ()=>{    distStatus.textContent = "SSE disconnected (sensor_service?)";  };}startSSE();