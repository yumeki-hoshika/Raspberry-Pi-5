import osimport timeimport threadingimport signalfrom datetime import datetime, timezone, timedeltafrom typing import Optionalfrom subprocess import Popenimport cv2from fastapi import FastAPI, Responsefrom fastapi.responses import StreamingResponse, FileResponsefrom fastapi.staticfiles import StaticFilesfrom pydantic import BaseModelfrom picamera2 import Picamera2JST = timezone(timedelta(hours=9))def session_id_now() -> str:    return datetime.now(JST).strftime("%Y%m%d_%H%M%S")class EVReq(BaseModel):    ev: floatclass LedReq(BaseModel):    on: boolclass CameraStream:    """    - プレビュー：1536x864 RGB -> JPEG(MJPEG)    - 静止画：switch_mode_and_capture_file でフル解像度    """    def __init__(self, cam_index: int, width: int, height: int, fps: int):        self.cam_index = cam_index        self.width = width        self.height = height        self.fps = fps        self.picam = Picamera2(cam_index)        self.lock = threading.Lock()        self.latest_jpeg: Optional[bytes] = None        self.running = False        self.cfg = self.picam.create_video_configuration(            main={"size": (width, height), "format": "RGB888"},            controls={"FrameRate": fps},        )        self.picam.configure(self.cfg)    def start(self):        self.picam.start()        self.running = True        threading.Thread(target=self._loop, daemon=True).start()        print(f"[CAM{self.cam_index}] started preview {self.width}x{self.height}@{self.fps}")    def _loop(self):        period = 1.0 / float(self.fps)        last_err_ts = 0.0        while self.running:            t0 = time.time()            try:                frame = self.picam.capture_array("main")  # RGB                bgr = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)                ok, enc = cv2.imencode(".jpg", bgr, [int(cv2.IMWRITE_JPEG_QUALITY), 80])                if ok:                    with self.lock:                        self.latest_jpeg = enc.tobytes()            except Exception as e:                now = time.time()                if now - last_err_ts > 1.0:                    print(f"[CAM{self.cam_index}] capture/encode error: {repr(e)}")                    last_err_ts = now                time.sleep(0.2)            dt = time.time() - t0            sleep = period - dt            if sleep > 0:                time.sleep(sleep)    def get_jpeg(self) -> Optional[bytes]:        with self.lock:            return self.latest_jpeg    def set_ev(self, ev: float):        # AEはONのまま ExposureValue だけ操作        self.picam.set_controls({"ExposureValue": float(ev)})    def stop(self):        self.running = False        try:            self.picam.stop()        except Exception:            pass        print(f"[CAM{self.cam_index}] stopped")# ===== LED control (libgpiod v2) =====# gpioset はデフォルトで終了しない（ライン値を保持する）ため、# subprocess.run では固まる可能性がある -> Popenで保持して ON/OFF でプロセスを切替える。LED_GPIOCHIP = os.environ.get("LED_GPIOCHIP", "gpiochip0")LED_LINE = int(os.environ.get("LED_LINE", "17"))_led_state = False_led_lock = threading.Lock()_led_proc: Optional[Popen] = Nonedef _kill_led_proc():    global _led_proc    if _led_proc is None:        return    try:        _led_proc.send_signal(signal.SIGINT)        _led_proc.wait(timeout=1.0)    except Exception:        try:            _led_proc.kill()        except Exception:            pass    _led_proc = Nonedef _start_led_hold(on: bool):    """    libgpiod v2 (推奨形):      gpioset -c gpiochip0 17=1   # ここで終了しない（保持）      gpioset -c gpiochip0 17=0   # 別プロセスで切替も可能    今回は「保持」を確実にするため、プロセスを1つだけ生かす。    """    global _led_proc    val = "1" if on else "0"    _kill_led_proc()    _led_proc = Popen(["gpioset", "-c", LED_GPIOCHIP, f"{LED_LINE}={val}"])def _set_led(on: bool):    _start_led_hold(on)    global _led_state    with _led_lock:        _led_state = bool(on)# ===== FastAPI App =====app = FastAPI()BASE_DIR = "/home/admin/dashcam"STATIC_DIR = os.path.join(BASE_DIR, "camera_service", "static")STORE_DIR = os.environ.get("CAM_STORE_DIR", os.path.join(BASE_DIR, "cam_store"))os.makedirs(STORE_DIR, exist_ok=True)# UIは /ui に（/stream が静的配信に吸われるのを防ぐ）app.mount("/ui", StaticFiles(directory=STATIC_DIR, html=True), name="static")@app.get("/")def root():    return Response(status_code=307, headers={"Location": "/ui/"})# プレビューは軽く（滑らかさ優先）cam0 = CameraStream(0, 1536, 864, 15)cam1 = CameraStream(1, 1536, 864, 15)capture_lock = threading.Lock()current_session: Optional[str] = Noneframe_counter = 0@app.on_event("startup")def startup():    cam0.start()    cam1.start()@app.on_event("shutdown")def shutdown():    cam0.stop()    cam1.stop()    _kill_led_proc()def mjpeg_generator(cam: CameraStream):    boundary = "frame"    while True:        jpg = cam.get_jpeg()        if jpg is None:            time.sleep(0.05)            continue        yield (            b"--%b\r\n"            b"Content-Type: image/jpeg\r\n"            b"Content-Length: %d\r\n\r\n" % (boundary.encode(), len(jpg))        ) + jpg + b"\r\n"        time.sleep(0.001)@app.get("/stream/0")def stream0():    return StreamingResponse(mjpeg_generator(cam0), media_type="multipart/x-mixed-replace; boundary=frame")@app.get("/stream/1")def stream1():    return StreamingResponse(mjpeg_generator(cam1), media_type="multipart/x-mixed-replace; boundary=frame")@app.post("/api/cam/0/ev")def set_ev0(req: EVReq):    cam0.set_ev(req.ev)    return {"ok": True, "cam": 0, "ev": req.ev}@app.post("/api/cam/1/ev")def set_ev1(req: EVReq):    cam1.set_ev(req.ev)    return {"ok": True, "cam": 1, "ev": req.ev}@app.get("/api/led")def led_get():    with _led_lock:        st = _led_state    return {"ok": True, "on": st, "chip": LED_GPIOCHIP, "line": LED_LINE}@app.post("/api/led")def led_set(req: LedReq):    try:        _set_led(req.on)        return {"ok": True, "on": req.on}    except FileNotFoundError:        return Response(content="gpioset not found (install libgpiod-tools)", status_code=500)    except Exception as e:        # permission や chip/line 指定ミスなどもここに来る        return Response(content=f"LED control error: {repr(e)}", status_code=500)def _ensure_dir(path: str):    os.makedirs(path, exist_ok=True)def _capture_still_to_file(cam: CameraStream, path: str):    # フル解像度を選ばせる（Picamera2がセンサ/チューニングに応じたstillを作る）    still_cfg = cam.picam.create_still_configuration()    cam.picam.switch_mode_and_capture_file(still_cfg, path)@app.post("/api/capture/shot")def capture_one_shot():    global current_session, frame_counter    with capture_lock:        if current_session is None:            current_session = session_id_now()            frame_counter = 0        sid = current_session        frame_counter += 1        idx = frame_counter    cam0_dir = os.path.join(STORE_DIR, "cam0", sid)    cam1_dir = os.path.join(STORE_DIR, "cam1", sid)    _ensure_dir(cam0_dir)    _ensure_dir(cam1_dir)    f0 = os.path.join(cam0_dir, f"{idx:06d}.jpg")    f1 = os.path.join(cam1_dir, f"{idx:06d}.jpg")    t0 = threading.Thread(target=_capture_still_to_file, args=(cam0, f0))    t1 = threading.Thread(target=_capture_still_to_file, args=(cam1, f1))    t0.start()    t1.start()    t0.join()    t1.join()    return {"ok": True, "session_id": sid, "index": idx, "files": {"cam0": f0, "cam1": f1}}@app.get("/download/{cam}/{session}/{filename}")def download_file(cam: str, session: str, filename: str):    path = os.path.join(STORE_DIR, cam, session, filename)    if not os.path.isfile(path):        return Response(status_code=404)    return FileResponse(path, filename=filename)