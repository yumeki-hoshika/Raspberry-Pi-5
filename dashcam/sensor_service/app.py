import osimport timeimport mathimport jsonimport threadingfrom collections import dequefrom datetime import datetime, timezone, timedeltafrom typing import Optional, Deque, Dict, Any, Iterablefrom fastapi import FastAPIfrom fastapi.responses import JSONResponse, StreamingResponse, PlainTextResponsefrom fastapi.middleware.cors import CORSMiddlewareimport smbus2JST = timezone(timedelta(hours=9))# ========= Config =========I2C_BUS = int(os.environ.get("MMC_I2C_BUS", "1"))MMC_ADDR = int(os.environ.get("MMC_I2C_ADDR", "0x30"), 16)UI_HZ = float(os.environ.get("UI_HZ", "1.0"))              # UIに送るHz（1Hz）AVG_WINDOW_SEC = float(os.environ.get("AVG_WINDOW_SEC", "1.0"))  # 平均化窓READ_HZ = float(os.environ.get("MMC_READ_HZ", "20.0"))     # 内部読み取りHz（トリガ式なら20Hzで十分）# ========= FastAPI =========app = FastAPI(title="sensor_service", version="1.1")app.add_middleware(    CORSMiddleware,    allow_origins=["*"],    allow_credentials=True,    allow_methods=["*"],    allow_headers=["*"],)_heading_buf: Deque[float] = deque(maxlen=10000)_heading_lock = threading.Lock()_last_distance_mm: Optional[float] = None_last_distance_status: str = "NO_DATA"_last_distance_valid_ratio: float = 0.0_last_distance_lock = threading.Lock()def now_iso() -> str:    return datetime.now(JST).isoformat()# ========= MMC5983MA registers (Datasheet) =========REG_XOUT_17_10 = 0x00REG_XOUT_9_2   = 0x01REG_YOUT_17_10 = 0x02REG_YOUT_9_2   = 0x03REG_ZOUT_17_10 = 0x04REG_ZOUT_9_2   = 0x05REG_XYZOUT_1_0 = 0x06REG_STATUS     = 0x08REG_CTRL0      = 0x09REG_CTRL1      = 0x0AREG_CTRL2      = 0x0B# STATUS bit0: Meas_M_Done（磁界測定完了）※Datasheetの説明に対応STATUS_MEAS_M_DONE_MASK = 0x01# CTRL0 bits（Datasheetのビット並びに合わせて決め打ち）BIT_TM_M       = 0  # Take magnetic field measurementBIT_TM_T       = 1BIT_INT_EN     = 2BIT_SET        = 3BIT_RESET      = 4BIT_AUTO_SR_EN = 5BIT_OTP_READ   = 6def mmc_write(bus: smbus2.SMBus, reg: int, val: int):    bus.write_byte_data(MMC_ADDR, reg, val & 0xFF)def mmc_read_block(bus: smbus2.SMBus, start: int, length: int):    return bus.read_i2c_block_data(MMC_ADDR, start, length)def mmc_init(bus: smbus2.SMBus):    # まずは安全側：CTRL1/CTRL2は0    mmc_write(bus, REG_CTRL1, 0x00)    mmc_write(bus, REG_CTRL2, 0x00)    # Auto set/reset 有効（推奨）    mmc_write(bus, REG_CTRL0, (1 << BIT_AUTO_SR_EN))    time.sleep(0.01)def mmc_trigger_measurement(bus: smbus2.SMBus):    # CTRL0はWrite-onlyなので read-modify-write は不可。必要なビットを全部含めて書く。    # Auto_SR_en + TM_M を同時に立てて測定開始    mmc_write(bus, REG_CTRL0, (1 << BIT_AUTO_SR_EN) | (1 << BIT_TM_M))def mmc_wait_meas_done(bus: smbus2.SMBus, timeout_s: float = 0.02):    t0 = time.time()    while True:        st = bus.read_byte_data(MMC_ADDR, REG_STATUS)        if (st & STATUS_MEAS_M_DONE_MASK) != 0:            return        if time.time() - t0 > timeout_s:            # タイムアウトでも読みに行ってみる（固まらせない）            return        time.sleep(0.001)def mmc_read_xyz_18bit(bus: smbus2.SMBus):    # 0x00..0x06 を一括読み（X/Y/Zの下位2bitは 0x06 に入っている）    b = mmc_read_block(bus, REG_XOUT_17_10, 7)    if len(b) != 7:        raise RuntimeError(f"MMC read len mismatch: {len(b)}")    x17_10 = b[0]    x9_2   = b[1]    y17_10 = b[2]    y9_2   = b[3]    z17_10 = b[4]    z9_2   = b[5]    xyz1_0 = b[6]    x1_0 = (xyz1_0 >> 6) & 0x03    y1_0 = (xyz1_0 >> 4) & 0x03    z1_0 = (xyz1_0 >> 2) & 0x03    x = (x17_10 << 10) | (x9_2 << 2) | x1_0    y = (y17_10 << 10) | (y9_2 << 2) | y1_0    z = (z17_10 << 10) | (z9_2 << 2) | z1_0    return x, y, zdef heading_from_xy(x: float, y: float) -> float:    ang = math.degrees(math.atan2(y, x))    if ang < 0:        ang += 360.0    return angdef mean_angle_deg(degs):    if not degs:        return None    sx = 0.0    sy = 0.0    for d in degs:        r = math.radians(d)        sx += math.cos(r)        sy += math.sin(r)    ang = math.degrees(math.atan2(sy, sx))    if ang < 0:        ang += 360.0    return angdef sensor_loop():    bus = smbus2.SMBus(I2C_BUS)    mmc_init(bus)    print(f"[sensor] MMC init ok (bus={I2C_BUS} addr={hex(MMC_ADDR)})")    period = 1.0 / max(1.0, READ_HZ)    last_err_print = 0.0    while True:        t0 = time.time()        try:            mmc_trigger_measurement(bus)            mmc_wait_meas_done(bus, timeout_s=0.02)            x, y, z = mmc_read_xyz_18bit(bus)            hd = heading_from_xy(x, y)            with _heading_lock:                _heading_buf.append(hd)        except Exception as e:            now = time.time()            if now - last_err_print > 2.0:                print(f"[sensor] MMC error: {repr(e)}")                last_err_print = now        dt = time.time() - t0        sl = period - dt        if sl > 0:            time.sleep(sl)@app.on_event("startup")def _startup():    threading.Thread(target=sensor_loop, daemon=True).start()def build_payload() -> Dict[str, Any]:    with _heading_lock:        buf = list(_heading_buf)    # 直近 READ_HZ * AVG_WINDOW_SEC を平均    n = max(1, int(READ_HZ * max(0.1, AVG_WINDOW_SEC)))    tail = buf[-n:] if len(buf) >= n else buf    h_avg = mean_angle_deg(tail)    with _last_distance_lock:        dist_mm = _last_distance_mm        dist_st = _last_distance_status        dist_vr = _last_distance_valid_ratio    return {        "ts": now_iso(),        "heading_deg_avg": h_avg,        "distance_mm_avg": dist_mm,        "distance_status": dist_st,        "distance_valid_ratio": dist_vr,    }@app.get("/", response_class=PlainTextResponse)def index():    return (        "sensor_service\n"        "Endpoints:\n"        "  GET  /api/sensors/latest\n"        "  GET  /api/sensors/stream  (SSE)\n"        "  GET  /health\n"    )@app.get("/health")def health():    with _heading_lock:        seen = len(_heading_buf) > 0    return {"ok": True, "mmc_seen": seen, "bus": I2C_BUS, "addr": hex(MMC_ADDR)}@app.get("/api/sensors/latest")def latest():    return JSONResponse(build_payload())@app.get("/api/sensors/stream")def stream():    def gen() -> Iterable[bytes]:        interval = 1.0 / max(0.1, UI_HZ)        while True:            payload = build_payload()            data = json.dumps(payload, ensure_ascii=False)            yield f"event: sensors\ndata: {data}\n\n".encode("utf-8")            time.sleep(interval)    return StreamingResponse(gen(), media_type="text/event-stream")